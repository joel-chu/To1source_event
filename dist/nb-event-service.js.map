{"version":3,"file":"nb-event-service.js","sources":["../src/store.js","../src/nb-event-service.js","../src/hash-code.js"],"sourcesContent":["export const NB_EVENT_SERVICE_PRIVATE_STORE = new WeakMap()\nexport const NB_EVENT_SERVICE_PRIVATE_LAZY = new WeakMap()\n","'use strict';\n/**\n * nb-event-service ES6 version rewrite\n * This version will be using the hash key to track the callback to avoid\n * the multiple calling the same function over and over again.\n */\nimport genHaskKey from './hash-code.js'\nimport {\n  NB_EVENT_SERVICE_PRIVATE_STORE,\n  NB_EVENT_SERVICE_PRIVATE_LAZY\n} from './store'\n\n// Default\nexport default class NBEventServiceCls {\n  /**\n   * class constructor\n   */\n  constructor(config = {}) {\n    if (config.logger && typeof config.logger === 'function') {\n      this.logger = config.logger;\n    }\n  }\n\n  /**\n   * logger for overwrite\n   */\n  logger() {}\n\n  //////////////////////////\n  //    PUBLIC METHODS    //\n  //////////////////////////\n  /**\n   * Register your evt handler, note we don't check the type here,\n   * we expect you to be sensible and know what you are doing.\n   * @param {string} evt name of event\n   * @param {function} callback bind method\n   * @param {object} context to execute this call in\n   * @return {boolean} result add or not\n   */\n  $on(evt , callback , context) {\n    const [hashKey , store] = this.prepareListener(evt , callback)\n    // should look at the lazyStore first !!!!\n    if (this.executeFnInLazyStore(evt , callback , context , hashKey) === false) {\n      // start with normal empty\n      if (!store[evt]) {\n        const payload = [this.saveToNormalStore(hashKey , callback , context)]\n        this.normalStore = this.mergeToStore(store , evt , payload)\n        this.logger('init store' , evt , payload)\n        return true;\n      }\n      else if (!this.findInStore(store[evt] , hashKey)) {  // already existed\n        // if this hashKey is not registered\n        store[evt].push(this.saveToNormalStore(hashKey , callback , context))\n        this.normalStore = store;\n        this.logger('append to store' , payload)\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * once only registered it once, there is no overwrite option here\n   * @param {string} evt name\n   * @param {function} callback to execute\n   * @return {boolean} result\n   */\n  $once(evt , callback , context) {\n    const [hashKey , store] = this.prepareListener(evt , callback);\n    // again this could create a problem if this already register in lazy store\n    // then someone else try to register with a normal on\n    if (this.executeFnInLazyStore(evt , callback , context , hashKey) === false) {\n      // if it's already registered, we skip it.\n      if (!store[evt]) {\n        const normalStore = this.normalStore;\n        // @TODO this might create problem later on\n        const obj = [this.saveToNormalStore(hashKey , callback , context)]\n        this.normalStore = this.mergeToStore(normalStore , evt , obj)\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * trigger the event\n   * @param {string} evts name\n   * @param {mixed} params pass to fn\n   * @param {object} context overwrite what stored\n   * @return {boolean} found or not\n   */\n  $trigger(evts , params , context) {\n    const store = this.normalStore;\n    evts = Array.isArray(evts) ? evts : [evts];\n    evts.forEach( (evt) => {\n      if (!store[evt]) { // not registered in normal store\n        this.logger('not registered put this in lazy store' , evt);\n        // TODO this is a bit confusing here\n        let lazyStore = this.lazyStore;\n        let args = Array.isArray(params) ? params : [params]\n        if (lazyStore[evt]) {\n          lazyStore[evt].push(args)\n        }\n        else {\n          lazyStore[evt] = [args]\n        }\n        this.lazyStore = lazyStore;\n        return false;\n      }\n      else {\n        store[evt].forEach( (config) => {\n          let args = Array.isArray(params) ? params : [params];\n          const [hashKey , _config] = config;\n          Reflect.apply(_config.fn, (context || _config.context), args)\n        })\n      }\n    })\n  }\n\n  /**\n   * remove the evt from normal store\n   * @param {string} evt name\n   * @return {boolean} result\n   */\n  $off(evt) {\n    const store = this.normalStore;\n    if (store[evt]) {\n      if (Reflect.deleteProperty(store , evt)) {\n        this.normalStore = store;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @return {object} store just return it\n   */\n  get $store() {\n    return this.normalStore;\n  }\n\n  /**\n   * This will be search the lazy store if found store in the normal store\n   * then convert the lazy store to the normal one here, and immediate execute\n   * the action\n   * @param {string} evt name\n   * @param {function} callback function\n   * @param {object} context to excute in\n   * @param {string} hashKey of the function\n   * @return {mixed} whathappened\n   */\n  executeFnInLazyStore(evt , callback , context , hashKey) {\n    const lazyStore = this.lazyStore;\n    if (lazyStore[evt]) { // only when this been registered in lazy store\n      lazyStore[evt].forEach( function(params) {\n        callback.apply(context , params)\n      })\n      // convert the lazy store to normal store\n      const normalStore = this.normalStore;\n      const obj = [this.saveToNormalStore(hashKey , callback , context)]\n      this.normalStore = this.mergeToStore(normalStore , evt , obj)\n      // remove from the lazy store\n      if (Reflect.deleteProperty(lazyStore , evt)) {\n        this.lazyStore = lazyStore;\n      }\n      return true;\n    }\n    return false; // just null because nothing happen\n  }\n  /**\n   * our own merge method\n   * @param {object} store the store to merge\n   * @param {string} key to add\n   * @param {mixed} value to add\n   * @return {object} store the newly defined store\n   */\n  mergeToStore(store , key , value) {\n    store[key] = value;\n    this.logger('check key value' , key , value)\n    return store;\n  }\n  /**\n   * shorthand to save to store store\n   * @param {object} obj to store\n   * @return {undefined} none\n   */\n  set normalStore(obj) {\n    NB_EVENT_SERVICE_PRIVATE_STORE.set(this, obj)\n  }\n\n  /**\n   * @return {object} store store\n   */\n  get normalStore() {\n    return NB_EVENT_SERVICE_PRIVATE_STORE.get(this) || {};\n  }\n\n  /**\n   * @param {object} obj to store\n   * @return {undefined} none\n   */\n  set lazyStore(obj) {\n    NB_EVENT_SERVICE_PRIVATE_LAZY.set(this , obj)\n  }\n\n  /**\n   * @return {object} store\n   */\n  get lazyStore() {\n    return NB_EVENT_SERVICE_PRIVATE_LAZY.get(this) || {};\n  }\n\n  /**\n   * @param {string} evt name\n   * @param {function} callback to store\n   * @param {string} key type of store\n   * @return {turple} result hashKey , store\n   */\n  prepareListener(evt , callback , key = 'store') {\n    if (typeof evt !== 'string') {\n      throw new Error('Expect event to be string')\n    }\n    const fn = key === 'store' ? 'normalStore' : 'lazyStore';\n    // create a hash code and check if this already been stored\n    const store = this['__' + fn + '__'];\n    const hashKey = this.hashFnToKey(callback)\n    return [hashKey , store];\n  }\n\n  /**\n   * @param {string} key hash\n   * @param {function} callback to store\n   * @param {object} context to exeucte it\n   * @return {object} result\n   */\n  saveToNormalStore(key , callback , context = null) {\n    return [key , {\n      fn: callback ,\n      context: context\n    }]\n  }\n\n  /**\n   * @param {object} store the event store\n   * @param {string} key hash\n   */\n  findInStore(store , key) {\n    return !!store.filter( s => {\n      const [hash,] = s;\n      return hash === key;\n    }).length;\n  }\n\n  /**\n   * generate a hashKey to identify the function call\n   * @param {function} fn the converted to string function\n   * @return {string} hashKey\n   */\n  hashFnToKey(fn) {\n    return genHaskKey(fn.toString())\n  }\n}\n\n// -- EOF --\n","/**\n * generate a 32bit hash based on the function.toString()\n * _from http://stackoverflow.com/questions/7616461/generate-a-hash-_from-string-in-javascript-jquery\n * @param {string} s the converted to string function\n * @return {string} the hashed function string\n */\nexport default function hashCode(s) {\n\treturn s.split(\"\").reduce(function(a,b){a=((a<<5)-a)+b.charCodeAt(0);return a&a},0)\n}\n"],"names":["const","NB_EVENT_SERVICE_PRIVATE_STORE","WeakMap","NB_EVENT_SERVICE_PRIVATE_LAZY","NBEventServiceCls","config","logger","this","$on","evt","callback","context","prepareListener","executeFnInLazyStore","hashKey","store","payload","saveToNormalStore","normalStore","mergeToStore","findInStore","push","$once","obj","$trigger","evts","params","Array","isArray","forEach","this$1","let","lazyStore","args","Reflect","apply","_config","fn","$off","deleteProperty","prototypeAccessors","$store","key","value","set","get","Error","hashFnToKey","filter","s","length","toString","split","reduce","a","b","charCodeAt"],"mappings":"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"}
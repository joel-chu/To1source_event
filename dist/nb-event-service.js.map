{"version":3,"file":"nb-event-service.js","sources":["../src/nb-event-service.js","../src/hash-code.js"],"sourcesContent":["'use strict';\n/**\n * nb-event-service ES6 version rewrite\n * This version will be using the hash key to track the callback to avoid\n * the multiple calling the same function over and over again.\n * that raise another question, what if multiple function bind to the same event\n * using the same callback but at different point?\n */\nimport genHaskKey from './hash-code.js';\n\nconst __NB_EVENT_SERVICE_PRIVATE_STORE__ = new WeakMap();\n\nconst __NB_EVENT_SERVICE_PRIVATE_LAZY__ = new WeakMap();\n\nexport default class NBEventServiceCls {\n    /**\n     * class constructor\n     */\n    constructor(config = {}) {\n      if (config.logger && typeof config.logger === 'function') {\n        this.logger = config.logger;\n      }\n    }\n\n    /**\n     * logger for overwrite\n     */\n    logger() {}\n\n    //////////////////////////\n    //    PUBLIC METHODS    //\n    //////////////////////////\n    /**\n     * Register your evt handler, note we don't check the type here,\n     * we expect you to be sensible and know what you are doing.\n     * @param {string} evt name of event\n     * @param {function} callback bind method\n     * @param {object} context to execute this call in\n     * @return {boolean} result add or not\n     */\n    $on(evt , callback , context)\n    {\n        const [hashKey , store] = this.__prepare__(evt , callback);\n        // should look at the lazyStore first !!!!\n        if (this.__executeLazyStore__(evt , callback , context , hashKey) === false) {\n            // start with normal empty\n            if (!store[evt]) {\n                const payload = [this.__constructToStore__(hashKey , callback , context)];\n                this.__normalStore__ = this.__merge__(store , evt , payload);\n                this.logger('init store' , evt , payload);\n                return true;\n            }\n            else if (!this.__find__(store[evt] , hashKey)) {  // already existed\n                // if this hashKey is not registered\n                store[evt].push(this.__constructToStore__(hashKey , callback , context))\n                this.__normalStore__ = store;\n                this.logger('append to store' , payload);\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * once only registered it once, there is no overwrite option here\n     * @param {string} evt name\n     * @param {function} callback to execute\n     * @return {boolean} result\n     */\n    $once(evt , callback , context)\n    {\n        const [hashKey , store] = this.__prepare__(evt , callback);\n        // again this could create a problem if this already register in lazy store\n        // then someone else try to register with a normal on\n        if (this.__executeLazyStore__(evt , callback , context , hashKey) === false) {\n            // if it's already registered, we skip it.\n            if (!store[evt]) {\n                const normalStore = this.__normalStore__;\n                // @TODO this might create problem later on\n                const obj = [this.__constructToStore__(hashKey , callback , context)];\n                this.__normalStore__ = this.__merge__(normalStore , evt , obj);\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * trigger the event\n     * @param {string} evts name\n     * @param {mixed} params pass to fn\n     * @param {object} context overwrite what stored\n     * @return {boolean} found or not\n     */\n    $trigger(evts , params , context)\n    {\n        const store = this.__normalStore__;\n        evts = Array.isArray(evts) ? evts : [evts];\n        evts.forEach( (evt) =>\n        {\n            if (!store[evt]) { // not registered in normal store\n                this.logger('not registered put this in lazy store' , evt);\n                // TODO this is a bit confusing here\n                let lazyStore = this.__lazyStore__;\n                params = Array.isArray(params) ? params : [params];\n                if (lazyStore[evt]) {\n                    lazyStore[evt].push(params);\n                }\n                else {\n                    lazyStore[evt] = [params];\n                }\n                this.__lazyStore__ = lazyStore;\n                return false;\n            }\n            else {\n                store[evt].forEach( (config) =>\n                {\n                    params = Array.isArray(params) ? params : [params];\n                    const [hashKey , _config] = config;\n                    _config.fn.apply(context || _config.context , params);\n                });\n            }\n        });\n    }\n    /**\n     * remove the evt from normal store\n     * @param {string} evt name\n     * @return {boolean} result\n     */\n    $off(evt)\n    {\n        const store = this.__normalStore__;\n        if (store[evt]) {\n            if (Reflect.deleteProperty(store , evt)) {\n                this.__normalStore__ = store;\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * @return {object} store just return it\n     */\n    get $store()\n    {\n        return this.__normalStore__;\n    }\n    /**\n     * This will be search the lazy store if found store in the normal store\n     * then convert the lazy store to the normal one here, and immediate execute\n     * the action\n     * @param {string} evt name\n     * @param {function} callback function\n     * @param {object} context to excute in\n     * @param {string} hashKey of the function\n     * @return {mixed} whathappened\n     */\n    __executeLazyStore__(evt , callback , context , hashKey)\n    {\n        const lazyStore = this.__lazyStore__;\n        if (lazyStore[evt]) { // only when this been registered in lazy store\n            lazyStore[evt].forEach( function(params)\n            {\n                callback.apply(context , params);\n            });\n            // convert the lazy store to normal store\n            const normalStore = this.__normalStore__;\n            const obj = [this.__constructToStore__(hashKey , callback , context)];\n            this.__normalStore__ = this.__merge__(normalStore , evt , obj);\n            // remove from the lazy store\n            if (Reflect.deleteProperty(lazyStore , evt)) {\n                this.__lazyStore__ = lazyStore;\n            }\n            return true;\n        }\n        return false; // just null because nothing happen\n    }\n    /**\n     * our own merge method\n     * @param {object} store the store to merge\n     * @param {string} key to add\n     * @param {mixed} value to add\n     * @return {object} store the newly defined store\n     */\n    __merge__(store , key , value)\n    {\n        store[key] = value;\n        // this.logger('check key value' , key , value);\n        return store;\n    }\n    /**\n     * shorthand to save to store store\n     * @param {object} obj to store\n     * @return {undefined} none\n     */\n    set __normalStore__(obj)\n    {\n        __NB_EVENT_SERVICE_PRIVATE_STORE__.set(this , obj);\n    }\n    /**\n     * @return {object} store store\n     */\n    get __normalStore__()\n    {\n        return __NB_EVENT_SERVICE_PRIVATE_STORE__.get(this) || {};\n    }\n    /**\n     * @param {object} obj to store\n     * @return {undefined} none\n     */\n    set __lazyStore__(obj)\n    {\n        __NB_EVENT_SERVICE_PRIVATE_LAZY__.set(this , obj);\n    }\n    /**\n     * @return {object} store\n     */\n    get __lazyStore__()\n    {\n        return __NB_EVENT_SERVICE_PRIVATE_LAZY__.get(this) || {};\n    }\n\n    /**\n     * @param {string} evt name\n     * @param {function} callback to store\n     * @param {string} key type of store\n     * @return {turple} result hashKey , store\n     */\n    __prepare__(evt , callback , key = 'store')\n    {\n        if (typeof evt !== 'string') {\n            throw 'Expect evt to be string';\n        }\n        const fn = key === 'store' ? 'normalStore' : 'lazyStore';\n        // create a hash code and check if this already been stored\n        const store = this['__' + fn + '__'];\n        const hashKey = this.__hashCode__(callback);\n        return [hashKey , store];\n    }\n    /**\n     * @param {string} key hash\n     * @param {function} callback to store\n     * @param {object} context to exeucte it\n     * @return {object} result\n     */\n    __constructToStore__(key , callback , context = null)\n    {\n        return [key , {\n            fn: callback ,\n            context: context\n        }];\n    }\n    /**\n     * @param {object} store the event store\n     * @param {string} key hash\n     */\n    __find__(store , key)\n    {\n        return !!store.filter( (s) =>\n        {\n            const [hash,] = s;\n            return hash === key;\n        }).length;\n    }\n    /**\n     * generate a hashKey to identify the function call\n     * @param {function} fn the converted to string function\n     * @return {string} hashKey\n     */\n    __hashCode__(fn)\n    {\n        return genHaskKey(fn.toString())\n    }\n}\n\n// -- EOF --\n","/**\n * generate a 32bit hash based on the function.toString()\n * _from http://stackoverflow.com/questions/7616461/generate-a-hash-_from-string-in-javascript-jquery\n * @param {string} s the converted to string function\n * @return {string} the hashed function string\n */\nexport default function hashCode(s) {\n\treturn s.split(\"\").reduce(function(a,b){a=((a<<5)-a)+b.charCodeAt(0);return a&a},0)\n}\n"],"names":["const","__NB_EVENT_SERVICE_PRIVATE_STORE__","WeakMap","__NB_EVENT_SERVICE_PRIVATE_LAZY__","NBEventServiceCls","config","logger","this","$on","evt","callback","context","__prepare__","__executeLazyStore__","hashKey","store","payload","__constructToStore__","__normalStore__","__merge__","__find__","push","$once","normalStore","obj","$trigger","evts","params","Array","isArray","forEach","this$1","let","lazyStore","__lazyStore__","_config","fn","apply","$off","Reflect","deleteProperty","prototypeAccessors","$store","key","value","set","get","__hashCode__","filter","s","length","toString","split","reduce","a","b","charCodeAt"],"mappings":"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"}